# 안전한 프로그램 작성

## 위험
> 지나치게 대담한 안심으로 망하는 것보다는 지나치게 마음 조이는 걱정으로 경멸당하는 것이 낫다. - 에드먼드 버트

해커들이 우리에게 원하는 것은 다음과 같은 것이다.

* 데이터 처리 능력
* 데이터 송신 능력(스팸)
* 사적으로 저장해 놓은 정보
* 기능 (소프트웨어)
* 다른 원격 시스템으로의 연결

** 어떤 자산을 가지고 있고 보호해야 하는지 알아야한다. **
다음은 흔히 일어나는 보안 위험과 손상이다.

* Private network에 연결해서 방어망을 뚫고 들어올 수 있다. 
* 결함이 있는 입력 루틴이 악용됨. (버퍼 오버플로우)
* 권한 상승(Privilege escalation) 루트 권한 탈취
* 통신 데이터 유출 (Man-in-the-middle attack)
* 데이터 변조 
* 조심성 없는 사용자에 의한 보안 위협
	* 로그아웃을 잊어버려 다른 사람이 사용할 수 있음 (세션 타임아웃 관련 설정)
	* 로그인 시도 제한 (Brute Force)
	

## 취약점의 감지

### 불안전한 설계와 아키텍처

** 아키텍처 수준에서 보안을 고려하지 않으면 모든 곳에서 보안에 관한 죄악을 저지르게 된다. ** <br/> 암호화하지 않은 데이터를 공중망을 통해서 내보내고, 쉽게 접근할 수 있는 매체에 데이터를 저장하고, 보안 결함이 있다고 알려진 소프트웨어 서비스를 작동시키게 된다.
보안은 개발이 시작되는 즉시 레이더에 나타나야 한다. 모든 시스템 컴포넌트에 시큐리티 홀(Security Hole : 보안 상의 허점)이 있는지 신경을 써야 한다. <br/>

** 컴퓨터는 그 시스템의 가장 덜 안전한 부분만큼만 안전하다 ** 

### 버퍼 오버런 (buffer overrun)
버퍼가 스택에 위치할 때 오버런을 악용하기 쉽다. 스택에 있는 함수 호출의 리턴 주소에 다른 데이터를 겹쳐 쓰면 CPU의 동작을 지시할 수도 있다. Heap 기반으로 하는 버퍼도 마찬가지로 악용될 수 있다.

### 임베디드 쿼리 스트링(embedded query strig)
프로그램을 붕괴, 임의의 코드를 실행, 사용 권한이 없는 데이터를 탈취하기 위해 사용될 수 있다. 버퍼 오버런처럼 입력 데이터의 파싱 실패에 의존하지만 경계를 무너뜨리는 것이 아니라, **제대로 걸러지지 않은 입력**을 프로그램이 그 다음에 하는 일에 악용하는 공격 하는 것이다.

데이터베이스 애플리케이션에 SQL 문을 은밀히 공급해서 임의의 데이터베이스 검색을 강제로 하도록 만들 수도 있다. (**SQL Injection**)

공격자의 입력으로부터 웹 어플리케이션을 거쳐서 최종적으로 희생자의 브라우저에 나타나는 **크로스 사이트 스크립팅(cross-site scripting) Exploit** 라는 공격도 있다.웹 기반 메시징 시스템에 있는 공격자의 가짜 코멘트는 그 페이지를 보고 있는 모든 브라우저에 표시된다.

### 경합 상태
시스템이 이벤트의 미묘한 순서에 의존하면, 의도하지 않은 공격을 일으키거나 코드를 붕괴시킬 수 있다. 이는 일반적으로 복잡하 스레드 모델 시스템이나, 여러 프로세스들이 협동 작업을 하는 시스템에서 나타날 수 있다. 

멀티스레드 프로그램에서는 메모리 풀을 공유하는데 그 버퍼를 적절하게 보호하지 않으면 데이터를 쓰는 스레드가 아직 풀어놓으려고 하지 않은 정보를 다른 스레드가 읽어갈 수 있다.

### 정소 오버플로우
변수 타입 설정이 잘못되어 있다면 정수 오버플로우가 일어난다. (unit*_t a = 254 + 2) == 0


## Security

* 시스템 설치
	* 정확한 OS 구성
	* 네트워크 하부구조
	* 어플리케이션의 버전 번호 
* 소프트웨어 시스템 설계
	* 로그인한 상태로 무한정 있을 수 있는지, 
	* 서브시스템이 어떻게 통신하는지
	* 어떤 프로토콜이 사용되는지 등의 설계 문제를 다루어야 함	
* 프로그램 구현
	* 반드시 무결함이어야 함 
* 시스템의 사용 절차

### 시스템 설치 테크닉

* 방화벽이나 스팸/바이러스 필터 보안 기술을 채용
* 로그를 철저하게 남기기
* 시스템으로 들어오는 접근 경로를 최소화하고, 각 사용자에게 최소한의 접근 권한만 허용하고, 사용자 풀(pool)은 가능한 한 줄이기
* 시스템 OS 설정을 올바르게
* 허니팟 설치

### 시스템 설계 테크닉
* 설계를 할 때 입력의 수를 제한, 모든 통신은 시스템의 한 부분만 통해서 하도록 해야함. 
* 모든 프로그램을 가장 제한된 권한 수준으로 실행. 꼭 필요한 경우에만 superuser로 프로그램을 실행ㅎ해야한다.
* 실질적으로 필요치 않은 기능은 모두 막아야 한다.
* 불안전한 라이브러리에 의존하지 말아야 한다.
* 보안 문제를 다루는 실행환경에 맞게 코드를 재단해야한다.
* 민감한 데이터는 될 수 있는 한 저장하지 말아야한다.

### 코드 구현 테크닉

* **방어적 프로그래밍**은  안전한 코드에 도달하기 위한 중요한 테크닉이다. 방어적 프로그래밍의 중심 원칙 - *아무것도 가정하지 마라* -는 정확히 안전한 프로그램의 작성에 관한 것이다. <br/> (사용자 입력, 프로그램 시작 명령, 환경 변수를 포함한) "**모든 입력을 체크하라**"와 "**모드 계산을 검증하라**" 같은 간단한 방어적 규칙이 당신의 코드로부터 무수히 많은 보안 취약점을 제거할 것이다. 
* 보안 감사(security audit)를 실시해라. 이것은 보안 전문가가 소스 코드를 조심스럽게 리뷰하는 것을 말한다. 전형적인 테스트 방식은 보안 결함을 많이 찾지 못할 것이다.
* Child Process를 만들 때는 아주 조심해야한다. 공격자가 서브태스크(subtask)의 방향을 바꾼 다음에 임의의 설비에 대한 제어권을 얻을 수 있다.
* **무자비**하게 테스트하고 디버깅해라. 될 수 있는 한 엄중하게 버그를 진압해라. 
* 모든 오퍼레이션을 아토믹 트랜잭션(atomic transaction)으로 포장해서 공격자가 경합 상태(race condition)을 악용할 수 없게 해라.

---

### 간추림
> 안전은 일종의 죽음입니다. - 테네시 윌리암스

#### 좋은 프로그래머는...
* 자기가 일하는 각 프로젝트의 보안 요구사항에 대해 알고 있다.
* 본능적으로 일반적인 보안 취약점을 피하면서 코드를 작성한다.
* 시스템 각각에 대해 보안을 설계한다. **보안을 마지막에 끼워 넣지 않는다**
* 보안을 테스트하는 전략을 가지고 있다.

#### 나쁜 프로그래머는...
* 보안이 별로 중요하지 않다고 간단하게 결론을 내려버린다.
* 자기가 보안 전문가라고 생각한다.
* 취약점이 발견되었을 때, 더 나쁜 경우로는 자기 코드가 손상되었을 때, 자기 프로그램에 있는 보안 결함에 대해서만 생각한다.
* 코드를 작성할 때만 보안에 초점을 맞추고, 설계나 아키텍처 수준에서는 보안을 무시한다.





 

	

