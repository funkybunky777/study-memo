#최적화 테크닉


## 1. 설계변경

* 느린 데이터 접근을 개선, 오래 걸리는 계산의 되풀이를 방지하기 위해 캐싱 또는 버퍼링 레이어 추가. 필요한 값은 미리 계산하고 계산된 결과를 저장
* Resource pool 을 만들어서 자원 할당의 부담 줄이기 
* 병렬화(parallelization) 기술과 스레드를 활용해서 한 동작이 다른 동작 뒤에 늘어서는 직렬화 방지하기. 코드의 심장부를 *반드시* 스레드 모델로 설계해야함
* 과도한 잠금(locking)을 피하거나 제거. 필수적인 잠금과 그렇지 않은 잠금을 구분하기 위해 정적 검사를 채용
* 과도한 익셉션 사용 피하기. 익셉션은 컴파일러가 하는 최적화를 막을 수 있음
* 필요없는 코드 삭제하기

## 2. 코드변경
* 루프풀기 : 반복문의 본체가 아주 짧을 경우에는 루프의 골격이 반복되는 동작보다 많은 부담이 될 수 있음
* 코드 인라인 : 작은 동작을 위해 함수를 호출하는 것은 큰 부담이 될 수 있다. 코드를 함수로 나누는 것은 코드가 더 명료해지고, 재사용을 통한 일관성이 생기고, 바뀌는 부분을 고립시킬 수 있다. 하지만 호출하는 코드와 호출되는 코드를 합하는 것이 성능에 도움이 된다.
* 상수 접기
* 컴파일 시간으로 이동 
* 강도 축소
* 죽은 코드의 제거 : 불필요한 코드는 작성하지 않는다.

## 3. 효율적인 코드 작성하기
 
 최적화하지 않는 것이 가장 좋은 접근 방법이라면, 코드의 성능을 향상시켜야 할 필요성은 어떻게 미리 막을 수 있을까. 그 답은 *설계* 이다. <br/>
모듈을 설계하면서 맹목적으로 성능을 쫓지는 말고 - 필요할 때만 그런 노력을 해라. 

---

## 4. 간추림
> 과학기술의 진보는 우리에게 더 효율적으로 뒤로 가는 수단을 제공했을 뿐입니다

### 좋은 프로그래머는...
* 최적화가 절대적으로 필요하다는 사실이 증명되지 않으면 최적화를 하지 않는다.
* 사려 깊고 신중한 접근 방법으로 체계적인 최적화를 시도한다.
* 코드 수준의 최적화에 호소하기 전에, 일찍 대안을 찾고 설계개선에 대해 연구한다.
* 코드의 품질을 퐈괴하지 않는 최적화를 선호한다.

### 나쁜 프로그래머는...
* 코드의 부적절성을 증명하기도 전에 최적화부터 시작한다. 
	* -> 코드를 최적화할 필요가 있는지, 최적화를 해야 할 만큼 심각한 문제인지, 정확히 어느 부분이 최적화가 필요한지 먼저 판단해야한다.
* 발부터 뛰어드는 다이빙을 한다 : 측정이나 조사도 하지 않고 보틀넥이라고 생각하는 코드를 공격한다  
	* 감으로 측정한 보틀넥은 틀리는 경우가 많다.
	* -> Profiling을 통해 정확히 측정을 한 이후에 최적화를 해야한다.
* 더 큰 그림을 고려하는 일이 없다. 
* 코드의 품질보다 속도가 더 중요하다고 생각한다.





