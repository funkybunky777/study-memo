# 바람직한 소프트웨어 설계

## 무엇을 설계하나
### 시스템 아키텍처
* 이 단계에서는 시스템을 전체적으로 살펴보고, 주요 서브 시스템을 식별하고, 서브 시스템이 서로 의사소통하는 방법을 고민하고 고안한다. 아키텍처 설계는 전체 시스템의 성능과 특성에 미치는 영향력이 가장 크고, 특정한 코드 행에 미치는 영향력은 가장 적다. 이것은 가장 중요한 설계이다. 

### 모듈/컴포넌트
* 아키텍처 설계에서 식별된 대부분의 서브시스템은 코드로 직접 구현하기에는 크기가 너무 크다. 때문에 각각의 서브시스템을 알기쉬운 더 작은 모듈들로 나눈다. 모듈 수준에서 설꼐를 하는 것은 애매해지기 아주 쉽다. 
* 모듈은 논리적인 코드 덩어리일 수도 있고, 자바 패키지 같은 물리적인 단위일 수도 있고, C++/C#의 네임스페일 수도 있으며 라이브러리일 수도 있ㄷ. 클래스일 수도 있고, 파일일 수도 있다.


### 클래스/데이터 타입
* 모듈을 덩어리들로 나눈다. 인터페이스의 설계는 비교적 덜 형식적이고 모듈의 배후에서 변경하기가 더 쉽다. 

### 함수
* 가장 낮은 수준의 설계이다. 정확히 어떤 함수가 필요한지 결정한 다음에 그 함수들이 내부적으로 어떻게 작동해야 할지, 제어 흐름은 어떤 경로를 따라가야 할지, 어떤 알고리즘을 사용해야 할지 설계해야 한다. 

## 무엇을 위해 설계하나
** 설계는 코드의 밑바탕이다. ** 잘못되면 코드는 불안정해지고, 쉽게 번복되고, 목적과 다른 동작을 하게 된다. 잘못된 설계는 필연적으로 피사의 사탑 같은 소프트웨어로 이끈다. 
걸실한 설계는 코드를 다음과 같은 것으로 만든다.

* 더 작성하기 쉽고
* 더 이해하기 쉽고
* 더 고치기 쉽고
* 버그의 잠복 가능성은 더 적고
* 변경에 대해 더 탄력적인 코드

## 좋은 설계

### 반복적이고
* 조금만 설계하고, 설계한 것을 구현하고, 구현한 것을 평가하고, 그 결과를 다음 설계에 공급해라. 점증적인 구축(Incremental Construction) 접근 방법은 아주 파워풀하다.



### 신중하고
* 한 번에 너무 많이 설계하려고 하지 말아라. 무언가 실패했을 때의 원인이 수많은 설계 결정으로 인한 것이 될지도 모른다. 실패할 수 있는 여지를 제한하면 일의 진행이 더 쉬워질 것이다. **작고 확실한** 설계 단계가 크고 서투른 설계 단계보다 성공할 확률이 높다.

### 현실적이고
* 정해진 규칙을 따르는 설계 프로세스가 항상, 매번 통하지는 않을 것이다. 결과는 요구사항의 품질, 팀의 경험, 적용되는 프로세스의 엄격함에 따라 달라진다. 여러 가지 방법론에서 가장 좋은 것들을 뽑아내고, 프로그래머의 직감에도 의존하도록 허용하는 접근 방법이 실용적이다. 

### 지식에 근거한
* 해결해야 할 문제를 명확히 하기 위해서는 요구사항과 동기가 되는 원칙들을 완전히 알아야 한다. 올바른 해법의 중요한 특성에 대해서도 완전히 알아야 한다. 

### 단순성
* 단순성은 잘 설계된 코드의 가장 중요한 트것ㅇ이다. 단순한 설계는 이해하기 쉽고, 불필요한 군더더기나 오점이 없고 구현하기가 쉽다.
* 단순한 코드는 가능한 만큼 작지만 너무 작지도 않다. 
* > 편지가 길어서 죄송합니다. 하지만 짧게 쓸 시간이 없었습니다. <br/>- Blaise Pascal
* 코드가 얼마나 적게 필요한지 신중하게 알아낸 다음에 꼭 그만큼만 작성하라. 기능을 추가하기 위해 나중에 언제든지 더 많은 코드를 추가할 수 있지만, 조밀하게 뒤엉킨 것 중 무언가를 삭제하는 일은 거의 불가능하다.

---
#### ** 확장성 vs 단순성 **
* 확장이 가능한 설계를 하기 위해서는 나중에 플러그인할 인터페이스 지점을 코드 안에 많이 만들어두어야 하고, 그렇게 만든 프레임워크는 나중에 발생하는 요구사항을 지원할 수 있을 정도로 충분히 일반적인 것이어야 한다. 단순한 설계를 하기 위해서는 간접성을 얻기 위해 여러 수준을 추가하거나, 불필요한 일반성을 얻기 위해 복잡해지는 일을 막아야 한다.

#### ** 효율성 vs 안전성 **
* 설계의 순수성을 희생시켜서 성능상의 이득을 얻는 경우가 종종 있다. 중요한 동작을 하기 위해 특수한 백도어를 만들어 두거나, 지나치게 간접적인 접근을 막기 위해 많으 커플링을 추가하는 것. 최적화가 많이 된 시스템은 대개 명료성이 떨어지고 변경에 마주했을 때 망가지기가 쉽다.

#### ** 기능 vs 노동량 **
* 프로젝트에 착수했을 때는 원하는 기능이 무수히 많이 있고, 언제까지 넘겨주어야 한다는 적당한 기한이 있다. 

---


### 세련미
* Elegance는 설계의 미적 양상의 실현이다. 이는 대개 단순성과 밀접한 관련이 있는데 코드가 기괴하거나, 너무 교묘해서 혼란스럽거나, 지나치게 복잡하지 않은 것을 의미한다. 잘 설계된 코드에는 구조적인 아름다움ㅇ이 있고, 다음과 같은 바람직한 특성들이 있다.
	* 제어의 흐름이 시스템의 곳곳을 우아하게 흘러다닌다.
	* 각 부분이 다른 부분을 보충하고, 다른 부분과 구별이 되는 가치를 추가한다.
	* 설계가 특별한 경우들로 도배질되어 있지 않는다.
	* 비슷한 것들이 서로 연관되어 있다.
	* 변경의 지역성이 좁다. 한 곳에서의 간단한 변경이 다른 많은 곳에서의 수정을 필요로 하지 않는다.
	
### 모듈화
* 설계 문제를 공략하면서 자연스럽게 이를 모듈이나 컴포넌트라고 불리는 부분들로 나누게 된다. 이는 서브시스템, 라이브러리, 패키지, 클래스 등으로 분해하게 되는데, 이 부분은 원래으 ㅣ문제보다 덜 복잡하고, 함께 모았을 때 완전한 솔루션이 된다.
* #### 강한 응집력
	* Cohesion은 한 모듈 안에 있는 기능들이 전체로서 얼마나 잘 작동하는지 측정하는 척도이다. 이는 여러 개의 모듈을 하나의 단위로 모으는 접착제이다. 응집력이 약한 모듈은 분해가 잘못되었다는 것을 알리는 신호이다. 각 모듈에는 명료하게 정의된 역할이 있어야 한다. 서로 관련이 없는 기능들을 아무렇게나 모아놓은 보따리가 되면 절대 안된다. (util 같은 네임스페이스...찔림)
* #### 낮은 커플링
	*  Coupling은 여러 모듈 간의 상호 의존성을 측정하는 척도이다. 한 모듈에서 다른 모듈로 얼마나 많으 ㄴ배선이 되었는지 측정하는 척도이다. 아주 단순한 설계에서는 모듈ㅇ 간의 커플링이 거의 없고 모듈 간의 의존성도 거의 없다. 
	* 모듈은 여러가지 방법으로 서로 연결되어 있다. 어떤 것은 직접적으로 연결되어 있고 어떤 것은 간접적으로 연결되어 있다. 한 모듈이 다른 모듈에 있는 함수를 호출할 수도 있고 다른 모듈에 의해 호출될 수도 있다. 다른 모듈에 있는 데이터 타입을 사용할 수도 있고, 데이터를 공유할 수도 있다.
	* 각각의 모듈이 식별되면 그 모듈만 따로 분리해서 작동시킬 수도 있고, 별도로 테스트할 수도 있다. 이것이 모듈화의 장점이다. 프로그래머들이 작업을 나누어 할 수 있기 때문이다. 

# TO BE CONTINUE
	 








